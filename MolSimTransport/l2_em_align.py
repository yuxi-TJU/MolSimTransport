'''
A python script that can automatically align user-built Extended Molecule (EM) with supplied electrode clusters.

When building EM, make sure that the three (or four) gold atoms on each side move as a whole (i.e. the relative 
positions between the gold atoms do not change).

Make sure that the index of three (or four) gold atoms on each side of EM are at the top and bottom of the xyz 
file, respectively (if the files are already sorted from smallest to largest in the Z direction).

*** We strongly recommend that DO NOT rotate the gold atoms on each side when building EM (Since the Hamiltonian 
of the whole system is partitioned based on coordinates ordered in the Z direction), unless you can ensure that 
the left and right electrode clusters and EM can be clearly divided in the Z direction.
'''

import numpy as np
from importlib.resources import files

def read_xyz(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        atom_count = int(lines[0].strip())
        atoms = []
        coordinates = []
        for line in lines[2:2 + atom_count]:
            parts = line.split()
            atoms.append(parts[0])
            coordinates.append([float(x) for x in parts[1:]])
        return np.array(atoms), np.array(coordinates)

def write_xyz(file_path, atoms, coordinates):
    sorted_indices = np.argsort(coordinates[:, 2])
    sorted_atoms = atoms[sorted_indices]
    sorted_coords = coordinates[sorted_indices]

    with open(file_path, 'w') as file:
        file.write(f"{len(atoms)}\n")
        file.write("Generated by alignment script\n")
        for atom, coord in zip(sorted_atoms, sorted_coords):
            file.write(f"{atom:<2} {coord[0]:>15.8f} {coord[1]:>15.8f} {coord[2]:>15.8f}\n")

def compute_alignment_transform(source_coords, target_coords):
    source_center = np.mean(source_coords, axis=0)
    target_center = np.mean(target_coords, axis=0)

    source_centered = source_coords - source_center
    target_centered = target_coords - target_center

    H = source_centered.T @ target_centered
    U, S, Vt = np.linalg.svd(H)
    R = Vt.T @ U.T
    if np.linalg.det(R) < 0:
        Vt[2, :] *= -1
        R = Vt.T @ U.T
    t = target_center - R @ source_center
    return R, t

def apply_transform(coordinates, R, t):
    return (R @ coordinates.T).T + t

def remove_duplicates(atoms, coordinates, tolerance=1e-3):
    unique_coords, unique_indices = np.unique(np.round(coordinates, decimals=3), axis=0, return_index=True)
    return atoms[unique_indices], unique_coords

def main():
    # Load the supplied cluster data
    # input_file = 'SuppliedCluster.xyz'
    input_file = files('share.em').joinpath('SuppliedCluster.xyz')
    
    cluster_atoms, cluster_coords = read_xyz(input_file)

    # Split the data into cluster_left and cluster_right
    cluster_left_atoms = cluster_atoms[:28]
    cluster_left_coords = cluster_coords[:28]
    cluster_right_atoms = cluster_atoms[28:56]
    cluster_right_coords = cluster_coords[28:56]

    # Read the EM data
    em_atoms, em_coords = read_xyz(input(">>> Enter EM xyz file name (e.g., coor.xyz): "))

    # Select specific atoms for cluster_left and EM
    cluster_left_indices = [-3, -2, -1]
    em_indices_for_left = [0, 1, 2]

    cluster_left_selected_coords = cluster_left_coords[cluster_left_indices]
    em_selected_coords_for_left = em_coords[em_indices_for_left]

    R_left, t_left = compute_alignment_transform(cluster_left_selected_coords, em_selected_coords_for_left)
    transformed_cluster_left_coords = apply_transform(cluster_left_coords, R_left, t_left)

    # Select specific atoms for cluster_right and EM
    cluster_right_indices = [0, 1, 2]
    em_indices_for_right = [-3, -2, -1]

    cluster_right_selected_coords = cluster_right_coords[cluster_right_indices]
    em_selected_coords_for_right = em_coords[em_indices_for_right]

    R_right, t_right = compute_alignment_transform(cluster_right_selected_coords, em_selected_coords_for_right)
    transformed_cluster_right_coords = apply_transform(cluster_right_coords, R_right, t_right)

    # Combine all structures and remove duplicates
    combined_atoms = np.concatenate((cluster_left_atoms, cluster_right_atoms, em_atoms))
    combined_coords = np.concatenate((transformed_cluster_left_coords, transformed_cluster_right_coords, em_coords))
    final_atoms, final_coords = remove_duplicates(combined_atoms, combined_coords)

    # Write the final structure to a new file
    write_xyz('aligned.xyz', final_atoms, final_coords)

    print("Alignment and combination complete. Output saved to 'aligned.xyz'.")

if __name__ == "__main__":
    main()
